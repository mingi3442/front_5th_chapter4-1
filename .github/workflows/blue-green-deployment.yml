name: True Blue-Green Deployment with Full Testing

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  NODE_VERSION: "18"
  HEALTH_CHECK_TIMEOUT: 30
  PERFORMANCE_THRESHOLD: 2.0 # seconds

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: |
          echo "ğŸ§ª Running unit tests..."
          npm test -- --coverage --watchAll=false

          echo "ğŸ” Running linting..."
          npm run lint

          echo "ğŸ—ï¸ Type checking..."
          npm run type-check

      - name: Build Next.js project
        run: |
          echo "ğŸ—ï¸ Building Next.js project..."
          npm run build

          # ë¹Œë“œ ê²°ê³¼ ê²€ì¦
          if [ ! -d "out" ]; then
            echo "âŒ Build output directory not found"
            exit 1
          fi

          echo "ğŸ“Š Build size analysis:"
          du -sh out/
          find out/ -name "*.js" -o -name "*.css" | wc -l

      - name: Setup AWS CLI and credentials
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
        run: |
          aws configure set aws_access_key_id "$AWS_ACCESS_KEY_ID"
          aws configure set aws_secret_access_key "$AWS_SECRET_ACCESS_KEY" 
          aws configure set default.region "$AWS_DEFAULT_REGION"

          echo "ğŸ” AWS connection test:"
          aws sts get-caller-identity

      - name: Install required tools
        run: |
          sudo apt-get update && sudo apt-get install -y jq bc curl

          # Lighthouse CLI for performance testing
          npm install -g @lhci/cli lighthouse

      - name: Determine current and target environments
        id: environment
        run: |
          echo "ğŸ” Determining current environment..."

          # í˜„ì¬ í”„ë¡œë•ì…˜ í™˜ê²½ì˜ Origin í™•ì¸
          CURRENT_ORIGIN=$(aws cloudfront get-distribution \
            --id ${{ secrets.PRODUCTION_DISTRIBUTION_ID }} \
            --query 'Distribution.DistributionConfig.Origins.Items[0].DomainName' \
            --output text)

          echo "Current origin: $CURRENT_ORIGIN"

          # Blue/Green í™˜ê²½ ê²°ì •
          if [[ $CURRENT_ORIGIN == *"blue"* ]]; then
            CURRENT_COLOR="blue"
            TARGET_COLOR="green"
            echo "ğŸ”µ Current: BLUE â†’ ğŸ¯ Target: GREEN"
          else
            CURRENT_COLOR="green"
            TARGET_COLOR="blue"
            echo "ğŸŸ¢ Current: GREEN â†’ ğŸ¯ Target: BLUE"
          fi

          # í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
          CURRENT_BUCKET="hanghae-prod-$CURRENT_COLOR"
          TARGET_BUCKET="hanghae-prod-$TARGET_COLOR"
          TARGET_URL="https://$TARGET_BUCKET.s3.amazonaws.com"

          echo "current_color=$CURRENT_COLOR" >> $GITHUB_OUTPUT
          echo "target_color=$TARGET_COLOR" >> $GITHUB_OUTPUT
          echo "current_bucket=$CURRENT_BUCKET" >> $GITHUB_OUTPUT
          echo "target_bucket=$TARGET_BUCKET" >> $GITHUB_OUTPUT
          echo "target_url=$TARGET_URL" >> $GITHUB_OUTPUT

          echo "ğŸ“‹ Environment Summary:"
          echo "  Current: $CURRENT_COLOR ($CURRENT_BUCKET)"
          echo "  Target:  $TARGET_COLOR ($TARGET_BUCKET)"
          echo "  URL:     $TARGET_URL"

      - name: Deploy to staging environment (target)
        run: |
          echo "ğŸ“¤ Deploying to staging environment: ${{ steps.environment.outputs.target_bucket }}"

          # S3 ë™ê¸°í™” with progress
          aws s3 sync out/ s3://${{ steps.environment.outputs.target_bucket }} \
            --delete \
            --exact-timestamps \
            --exclude "*.map" \
            --cache-control "public, max-age=31536000, immutable" \
            --metadata-directive REPLACE

          echo "âœ… Deployment to staging completed"

      - name: Wait for S3 propagation
        run: |
          echo "â³ Waiting for S3 propagation..."
          sleep 10

      - name: Basic health checks
        run: |
          echo "ğŸ¥ Running basic health checks..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # ê¸°ë³¸ ì—°ê²°ì„± í™•ì¸
          echo "1. Testing basic connectivity..."
          if ! curl -f --max-time ${{ env.HEALTH_CHECK_TIMEOUT }} "$TARGET_URL/"; then
            echo "âŒ Basic connectivity test failed"
            exit 1
          fi

          # HTML êµ¬ì¡° í™•ì¸
          echo "2. Validating HTML structure..."
          RESPONSE=$(curl -s "$TARGET_URL/")
          if [[ ! $RESPONSE == *"<html"* ]] || [[ ! $RESPONSE == *"</html>"* ]]; then
            echo "âŒ Invalid HTML structure"
            exit 1
          fi

          # í•„ìˆ˜ ë©”íƒ€ íƒœê·¸ í™•ì¸
          if [[ ! $RESPONSE == *"<title>"* ]]; then
            echo "âŒ Missing title tag"
            exit 1
          fi

          echo "âœ… Basic health checks passed"

      - name: Comprehensive functionality tests
        run: |
          echo "ğŸ§ª Running comprehensive functionality tests..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # ë©”ì¸ í˜ì´ì§€ë§Œ í™•ì¸ (ë‹¨ì¼ í˜ì´ì§€ ì• í”Œë¦¬ì¼€ì´ì…˜)
          echo "Testing main page: /"
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET_URL/")
          if [[ $STATUS_CODE != "200" ]]; then
            echo "âŒ Main page returned status $STATUS_CODE"
            exit 1
          fi
          echo "âœ… Main page test passed"

          # JavaScript ë²ˆë“¤ ë¡œë”© í™•ì¸
          echo "Testing JavaScript bundles..."
          JS_FILES=$(curl -s "$TARGET_URL/" | grep -o '_next/static/chunks/[^"]*\.js' | head -5)
          for js_file in $JS_FILES; do
            if ! curl -f -s "$TARGET_URL/$js_file" > /dev/null; then
              echo "âŒ JavaScript file failed to load: $js_file"
              exit 1
            fi
          done

          # CSS íŒŒì¼ í™•ì¸
          echo "Testing CSS files..."
          CSS_FILES=$(curl -s "$TARGET_URL/" | grep -o '_next/static/css/[^"]*\.css' | head -3)
          for css_file in $CSS_FILES; do
            if ! curl -f -s "$TARGET_URL/$css_file" > /dev/null; then
              echo "âŒ CSS file failed to load: $css_file"
              exit 1
            fi
          done

          echo "âœ… Functionality tests passed"

      - name: Performance testing
        run: |
          echo "âš¡ Running performance tests..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # ì‘ë‹µ ì‹œê°„ ì¸¡ì •
          echo "1. Testing response times..."
          for i in {1..3}; do
            RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" "$TARGET_URL/")
            echo "  Attempt $i: ${RESPONSE_TIME}s"
            
            if (( $(echo "$RESPONSE_TIME > ${{ env.PERFORMANCE_THRESHOLD }}" | bc -l) )); then
              echo "âŒ Response time too slow: ${RESPONSE_TIME}s (threshold: ${{ env.PERFORMANCE_THRESHOLD }}s)"
              exit 1
            fi
          done

          # íŒŒì¼ í¬ê¸° í™•ì¸
          echo "2. Testing resource sizes..."
          MAIN_PAGE_SIZE=$(curl -s "$TARGET_URL/" | wc -c)
          echo "  Main page size: $MAIN_PAGE_SIZE bytes"

          if [ $MAIN_PAGE_SIZE -gt 1048576 ]; then  # 1MB
            echo "âŒ Main page too large: $MAIN_PAGE_SIZE bytes"
            exit 1
          fi

          echo "âœ… Performance tests passed"

      - name: Lighthouse performance audit
        run: |
          echo "ğŸ” Running Lighthouse performance audit..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # Lighthouse ì‹¤í–‰ (headless)
          lighthouse "$TARGET_URL" \
            --output=json \
            --output-path=./lighthouse-report.json \
            --chrome-flags="--headless --no-sandbox --disable-dev-shm-usage" \
            --quiet

          # ì„±ëŠ¥ ì ìˆ˜ í™•ì¸
          PERFORMANCE_SCORE=$(jq '.categories.performance.score * 100' lighthouse-report.json)
          echo "Performance Score: $PERFORMANCE_SCORE"

          # ìµœì†Œ ì ìˆ˜ í™•ì¸ (70ì  ì´ìƒ)
          if (( $(echo "$PERFORMANCE_SCORE < 70" | bc -l) )); then
            echo "âŒ Performance score too low: $PERFORMANCE_SCORE (minimum: 70)"
            exit 1
          fi

          echo "âœ… Lighthouse audit passed with score: $PERFORMANCE_SCORE"

      - name: Load testing
        run: |
          echo "ğŸ”¥ Running basic load test..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # ë™ì‹œ ìš”ì²­ í…ŒìŠ¤íŠ¸ (ê°„ë‹¨í•œ ë²„ì „)
          echo "Testing concurrent requests..."
          for i in {1..10}; do
            curl -s "$TARGET_URL/" > /dev/null &
          done
          wait

          # ì„œë²„ê°€ ì—¬ì „íˆ ì‘ë‹µí•˜ëŠ”ì§€ í™•ì¸
          if ! curl -f --max-time 10 "$TARGET_URL/" > /dev/null; then
            echo "âŒ Server failed after load test"
            exit 1
          fi

          echo "âœ… Load test passed"

      - name: API endpoints testing (if applicable)
        run: |
          echo "ğŸ”Œ Testing API endpoints..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # API í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸ê°€ ìˆë‹¤ë©´
          API_ENDPOINTS=("/api/health" "/api/status")

          for endpoint in "${API_ENDPOINTS[@]}"; do
            echo "Testing API endpoint: $endpoint"
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET_URL$endpoint" || echo "000")
            
            if [[ $STATUS_CODE == "200" ]]; then
              echo "âœ… API endpoint $endpoint: OK"
            elif [[ $STATUS_CODE == "404" ]]; then
              echo "â„¹ï¸ API endpoint $endpoint: Not found (skipping)"
            else
              echo "âŒ API endpoint $endpoint failed with status: $STATUS_CODE"
              exit 1
            fi
          done

          echo "âœ… API testing completed"

      - name: Security headers check
        run: |
          echo "ğŸ”’ Checking security headers..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # ë³´ì•ˆ í—¤ë” í™•ì¸
          HEADERS=$(curl -I -s "$TARGET_URL/")

          # ì²´í¬í•  ë³´ì•ˆ í—¤ë”ë“¤
          SECURITY_HEADERS=(
            "X-Frame-Options"
            "X-Content-Type-Options"
            "Referrer-Policy"
          )

          for header in "${SECURITY_HEADERS[@]}"; do
            if echo "$HEADERS" | grep -i "$header" > /dev/null; then
              echo "âœ… Security header present: $header"
            else
              echo "âš ï¸ Security header missing: $header"
            fi
          done

      - name: Final staging validation
        run: |
          echo "ğŸ¯ Final staging environment validation..."
          TARGET_URL="${{ steps.environment.outputs.target_url }}"

          # ë§ˆì§€ë§‰ ì¢…í•© í™•ì¸
          echo "1. Final connectivity test..."
          curl -f --max-time 15 "$TARGET_URL/" > /dev/null

          echo "2. Critical path test..."
          # ë©”ì¸ í˜ì´ì§€ë§Œ í•œ ë²ˆ ë” í™•ì¸
          curl -f --max-time 15 "$TARGET_URL/" > /dev/null

          echo "3. Asset availability test..."
          CRITICAL_ASSETS=$(curl -s "$TARGET_URL/" | grep -o '_next/static/[^"]*' | head -3)
          for asset in $CRITICAL_ASSETS; do
            curl -f -s "$TARGET_URL/$asset" > /dev/null
          done

          echo "âœ… Staging environment fully validated and ready for production switch"

      - name: Switch CloudFront to new environment
        id: switch
        run: |
          echo "ğŸ”„ Switching CloudFront from ${{ steps.environment.outputs.current_color }} to ${{ steps.environment.outputs.target_color }}"

          # í˜„ì¬ CloudFront ì„¤ì • ë°±ì—…
          aws cloudfront get-distribution --id ${{ secrets.PRODUCTION_DISTRIBUTION_ID }} > current-dist.json
          ETAG=$(jq -r '.ETag' current-dist.json)

          echo "switch_etag=$ETAG" >> $GITHUB_OUTPUT

          # ìƒˆë¡œìš´ Origin ë„ë©”ì¸ ì„¤ì •
          NEW_DOMAIN="${{ steps.environment.outputs.target_bucket }}.s3.amazonaws.com"

          # ë°°í¬ ì„¤ì • ì—…ë°ì´íŠ¸
          jq --arg domain "$NEW_DOMAIN" \
             '.Distribution.DistributionConfig.Origins.Items[0].DomainName = $domain' \
             current-dist.json | \
          jq '.Distribution.DistributionConfig' > new-config.json

          # CloudFront ì—…ë°ì´íŠ¸ ì‹¤í–‰
          UPDATE_RESULT=$(aws cloudfront update-distribution \
            --id ${{ secrets.PRODUCTION_DISTRIBUTION_ID }} \
            --distribution-config file://new-config.json \
            --if-match $ETAG)

          echo "âœ… CloudFront switch initiated"
          echo "New Origin: $NEW_DOMAIN"

      - name: Wait for CloudFront deployment
        run: |
          echo "â³ Waiting for CloudFront deployment to complete..."

          # CloudFront ë°°í¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§
          DISTRIBUTION_ID="${{ secrets.PRODUCTION_DISTRIBUTION_ID }}"

          for i in {1..30}; do
            STATUS=$(aws cloudfront get-distribution --id $DISTRIBUTION_ID --query 'Distribution.Status' --output text)
            echo "Deployment status ($i/30): $STATUS"
            
            if [[ "$STATUS" == "Deployed" ]]; then
              echo "âœ… CloudFront deployment completed"
              break
            fi
            
            if [[ $i -eq 30 ]]; then
              echo "âŒ CloudFront deployment timed out"
              exit 1
            fi
            
            sleep 30
          done

      - name: Production health check
        run: |
          echo "ğŸ¥ Running production health checks..."
          PROD_URL="https://prod.min71.dev"

          # í”„ë¡œë•ì…˜ URLì—ì„œ ìƒˆ í™˜ê²½ í™•ì¸
          echo "1. Testing production URL..."
          for i in {1..5}; do
            if curl -f --max-time 30 "$PROD_URL/" > /dev/null; then
              echo "âœ… Production health check passed (attempt $i)"
              break
            else
              echo "â³ Production health check failed, retrying... (attempt $i/5)"
              if [[ $i -eq 5 ]]; then
                echo "âŒ Production health check finally failed"
                exit 1
              fi
              sleep 10
            fi
          done

          # ìºì‹œ ìƒíƒœ í™•ì¸
          echo "2. Checking cache status..."
          CACHE_STATUS=$(curl -I -s "$PROD_URL/" | grep -i "x-cache" || echo "No cache header")
          echo "Cache Status: $CACHE_STATUS"

      - name: Invalidate CloudFront cache
        run: |
          echo "ğŸ”„ Invalidating CloudFront cache..."

          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.PRODUCTION_DISTRIBUTION_ID }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)

          echo "Invalidation ID: $INVALIDATION_ID"
          echo "âœ… Cache invalidation initiated"

      - name: Post-deployment verification
        run: |
          echo "ğŸ” Post-deployment verification..."
          PROD_URL="https://prod.min71.dev"

          # 1ë¶„ê°„ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸ (ê°„ë‹¨í•˜ê²Œ)
          echo "Running 1-minute stability test..."
          for i in {1..4}; do
            if ! curl -f --max-time 15 "$PROD_URL/" > /dev/null; then
              echo "âŒ Post-deployment stability test failed at check $i"
              exit 1
            fi
            echo "âœ… Stability check $i/4 passed"
            sleep 15
          done

          echo "âœ… Post-deployment verification completed"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "ğŸš¨ Deployment failed! Initiating rollback..."

          # ì´ì „ ì„¤ì •ìœ¼ë¡œ ë¡¤ë°±
          if [[ -f "current-dist.json" ]] && [[ -n "${{ steps.switch.outputs.switch_etag }}" ]]; then
            echo "Rolling back CloudFront to previous configuration..."
            
            # ì›ë˜ ì„¤ì • ë³µì›
            jq '.Distribution.DistributionConfig' current-dist.json > rollback-config.json
            
            aws cloudfront update-distribution \
              --id ${{ secrets.PRODUCTION_DISTRIBUTION_ID }} \
              --distribution-config file://rollback-config.json \
              --if-match ${{ steps.switch.outputs.switch_etag }}
            
            echo "âœ… Rollback completed"
          else
            echo "âš ï¸ Rollback configuration not available"
          fi

      - name: Cleanup old environment
        if: success()
        run: |
          echo "ğŸ§¹ Cleaning up old environment..."

          # ì´ì „ í™˜ê²½(í˜„ì¬ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ”)ì˜ ì˜¤ë˜ëœ íŒŒì¼ ì •ë¦¬
          OLD_BUCKET="${{ steps.environment.outputs.current_bucket }}"

          # 30ì¼ ì´ìƒ ëœ íŒŒì¼ ì‚­ì œ (ì„ íƒì )
          echo "Cleaning old files from $OLD_BUCKET..."
          # aws s3api list-objects-v2 --bucket $OLD_BUCKET ë“±ì„ ì‚¬ìš©í•œ ì •ë¦¬ ë¡œì§

          echo "âœ… Cleanup completed"

      - name: Deployment summary and notifications
        if: always()
        run: |
          echo "ğŸ“Š DEPLOYMENT SUMMARY"
          echo "===================="`
          echo "ğŸ¯ Target Environment: ${{ steps.environment.outputs.target_color }}"
          echo "ğŸ“¦ Target Bucket: ${{ steps.environment.outputs.target_bucket }}"
          echo "ğŸŒ Production URL: https://prod.min71.dev"
          echo "ğŸ“… Deployment Time: $(date)"
          echo "ğŸ”„ Status: ${{ job.status }}"

          if [[ "${{ job.status }}" == "success" ]]; then
            echo "ğŸ‰ Blue-Green deployment completed successfully!"
            echo "âœ… All health checks passed"
            echo "âœ… Performance tests passed"
            echo "âœ… Production environment updated"
          else
            echo "âŒ Deployment failed - rollback initiated"
          fi

          # Slack ì•Œë¦¼ (ì„ íƒì )
          # curl -X POST -H 'Content-type: application/json' \
          #   --data "{\"text\":\"Deployment ${{ job.status }}: ${{ steps.environment.outputs.target_color }}\"}" \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
